
function assr4(varargin)
% Lattice definition file - generated by dimad2at v1.300000 
%
% Eugene 2004-12-13 Updating the generalised file to realign the family
% names and elements with aspinit. NOTE: aspinit will not work with split
% elements... not without modification of the init file.
%
% Eugene 2005-09-16 Standardise all lattices being used to this. "Custom"
% versions of the lattice files, eg for ML, ID studies etc will take this
% file as a template. The following major changes were made -
%    * All family names in CAPS in line with ALS and SPEAR convention.
%    * Dipole path and gradient updated to reflect numerical studies on
%      measured data. Quadrupole values fitted for a tune of 13.3, 5.2 and
%      zero dispersion given the new dipole gradient fields.
%    * Merged with "aspsr_msrf.m" with independent/individual cavitie(s).
%    * Element positions/lengths should be inline with engineering
%      drawings.

global FAMLIST THERING GLOBVAL

GLOBVAL.E0 = 3e9;
GLOBVAL.LatticeFile = mfilename;
FAMLIST = cell(0);

L0 = 2.159946602239996e+02; % calculated using findspos %215.9945540689991;% with new dipole path lengths. Designed for 216m.
C0 = 299792458; 	   % speed of light [m/s]
HarmNumber = 360;

disp(' ');
fprintf('*** Loading lattice from %s.m ***\n',GLOBVAL.LatticeFile);

% With AT1.3 ringpass and linepass, particles limited by the apperturepass
% will have [x,x',y,y',delta,dl] = [NaN,0,0,0,0,0]. All pass methods will
% check for this and do nothing to particles with these coordinates.
% Ring/linepass will both return particle positions as well as the number
% of turns the particles achieved.
% ap  =   aperture('AP',[-32 17 -16 16]*1e-3,'AperturePass');
ap  =   aperture('AP',[-16 17 -16 16]*1e2,'AperturePass');

d1	=	drift('D1'	,2.698300e+000,'DriftPass'); % (2.698286 -> to get closer to the design distance of 216m)
d2	=	drift('D2'	,1.900000e-001,'DriftPass');
d3	=	drift('D3'	,1.650000e-001,'DriftPass');
d4	=	drift('D4'	,2.750000e-001,'DriftPass');
d5	=	drift('D5'	,1.550000e-001,'DriftPass');
d6	=	drift('D6'	,4.500000e-001,'DriftPass');

% Modified drifts around BPM sections.
bpm	=	monitor('BPM'	,'IdentityPass');
d1a	=	drift('D1A'	,len(d1)-3.942860e-001,'DriftPass'); % 2.304000e+000
d1b	=	drift('D1B'	,        3.942860e-001,'DriftPass');
d1aa=	drift('D1A'	,len(d1)-0.58,'DriftPass'); % Last bpm
d1bb=	drift('D1B'	,        0.58,'DriftPass');
d4a	=	drift('D4A'	,len(d4)-1.990000e-001,'DriftPass'); % 7.600000e-002
d4b	=	drift('D4B'	,        1.990000e-001,'DriftPass');
d4aa	=	drift('D4AA'	,len(d4)-6.400000e-002,'DriftPass'); % 2.110000e-001
d4bb	=	drift('D4BB'	,        6.400000e-002,'DriftPass');
d2a	=	drift('D2A'	,len(d2)-1.030000e-001,'DriftPass'); % 8.700000e-002
d2b	=	drift('D2B'	,        1.030000e-001,'DriftPass');

% Dipoles
% design -> rbend('BEND',1.726000e+000,2.243995e-001,...
%                     1.121997e-001,1.121997e-001,-3.349992e-001,[method]);
% From numerical studies ->   L: 1.72579121675e+000
%                             K: 0.33295132
%                          Sext: 0.01092687
%                           Oct: 0.15166053
scalek = 0.98855592463187;
edge_offset = 0.03603626237179;
dip1	=	rbend('BEND'	,1.72579121675e+000,2.243995e-001,1.121997e-001+edge_offset,1.121997e-001+edge_offset,-0.33295132*scalek,'BndMPoleSymplectic4Pass');
dip2	=	rbend('BEND'	,1.72579121675e+000,2.243995e-001,1.121997e-001+edge_offset,1.121997e-001+edge_offset,-0.33295132*scalek,'BndMPoleSymplectic4Pass');

% Quadrupoles (for design dipole: [QFA,QDA,QFB]=[1.761741,-1.038377,1.533802];
% To match new dipole values from numerical studies
% tune of 13.3, 5.2 and 0 dispersion in straights.
% qfa	=	quadrupole('QFA'	,3.550000e-001, 1.7610967e+000,'QuadLinearPass');
% qda	=	quadrupole('QDA'	,1.800000e-001,-1.0715748e+000,'QuadLinearPass');
% qfb	=	quadrupole('QFB'	,3.550000e-001, 1.5406418e+000,'QuadLinearPass');
% To match split dipole values from numerical studies (SBENDS)
% tune of 13.29, 5.216 and 0 dispersion in straights.
qfa	=	quadrupole('QFA'	,3.550000e-001, 1.76272982211693,'QuadLinearPass');
qda	=	quadrupole('QDA'	,1.800000e-001,-1.06276736743823,'QuadLinearPass');
qfb	=	quadrupole('QFB'	,3.550000e-001, 1.53992875479511,'QuadLinearPass');


% Sextupoles with built in correctors. Corrector settings given by kick
% angle in radians.
sfa	=	sextcorr('SFA'	,2.000000e-001, 1.400000e+001,[0 0],'StrCorrMPoleSymplectic4Pass');
sda	=	sextcorr('SDA'	,2.000000e-001,-1.400000e+001,[0 0],'StrCorrMPoleSymplectic4Pass');
sdb	=	sextcorr('SDB'	,2.000000e-001,-7.014635e+000,[0 0],'StrCorrMPoleSymplectic4Pass');
sfb	=	sextcorr('SFB'	,2.000000e-001, 7.189346e+000,[0 0],'StrCorrMPoleSymplectic4Pass');

% Define the wiggler as a 6x6 matrix element pass
wig = marker('wig','Matrix66Pass');
L = 0;
Kx = 0; Ky = 0;
FAMLIST{wig}.ElemData.M66 = [1  L  0  0  0  0;
                             Kx 1  0  0  0  0;
                             0  0  1  L  0  0;
                             0  0  Ky 1  0  0;
                             0  0  0  0  1  0;
                             0  0  0  0  0  1];

                         
% Define the APPLE2 as a 6x6 matrix element pass
app = marker('wig','Matrix66Pass');
L = 0;
Kx = 0; Ky = 0;
FAMLIST{app}.ElemData.M66 = [1  L  0  0  0  0;
                             Kx 1  0  0  0  0;
                             0  0  1  L  0  0;
                             0  0  Ky 1  0  0;
                             0  0  0  0  1  0;
                             0  0  0  0  0  1];

% RF cavity and the corresponding straight used to position the cavity.
% 4.996540652069698e+008 old freq for 216m for 216.0004 its different. Also
% we are using ThinCavities therefore the drifts have to be set
% accordingly.
cav_single = rfcavity('RF' ,0.0,3.00e+006,C0/L0*HarmNumber,HarmNumber,'CavityPass'); 
cav        = rfcavity('RF' ,0.0,0.75e+006,C0/L0*HarmNumber,HarmNumber,'CavityPass');
% drifts around the rf cavities and space between them
d1ar1    =   drift('D1AR1'	,len(d1a)-len(cav_single)/2  ,'DriftPass'); % for just 1 cavity
drf      =	 drift('DRF'    ,0.45                        ,'DriftPass'); % space between cavities
d1ar4	 =	 drift('D1AR4'	,len(d1a)-len(cav)-len(drf)/2,'DriftPass'); % for 4 cavities
cav_pair = [cav drf cav];
dRF1 = drift('dRF1'	,len(d1)-2.55  ,'DriftPass');
dRF2 = drift('dRF2'	,2.55/3  ,'DriftPass');


% Kickers and the associated drifts to position them. (to be checked)
kick1	=	corrector('KICK'	,0.000000e+000,[0.000000e+000 0.0],'CorrectorPass');
kick2	=	corrector('KICK'	,0.000000e+000,[0.000000e+000 0.0],'CorrectorPass');
kick3	=	corrector('KICK'	,0.000000e+000,[0.000000e+000 0.0],'CorrectorPass');
kick4	=	corrector('KICK'	,0.000000e+000,[0.000000e+000 0.0],'CorrectorPass');
%fast feedback kicks
ffbh	=	corrector('FFBH'	,0.000000e+000,[0.000000e+000 0.0],'CorrectorPass');
ffbv    =   corrector('FFBV'    ,0.000000e+000,[0.000000e+000 0.0],'CorrectorPass');
% Drift spaces to replace D1A for the upstream kickers, ie kickers 1 and 3.
d1ak2_up=	drift('D1AK2_UP'	,0.779 - len(d1b),'DriftPass');
d1ak1_up=	drift('D1AK1_UP'	,len(d1a) - len(d1ak2_up),'DriftPass');
% Drift spaces to replace D1A for the downstream kickers, ie kickers 2 and 4.
d1ak2_do=	drift('D1AK2_DO'	,1.073 - len(d1bb),'DriftPass');
d1ak1_do=	drift('D1AK1_DO'	,len(d1aa) - len(d1ak2_do),'DriftPass');


% Define the position of the bpm. bpm1d1 represents BPM number 1 in the D1
% straight and bpm5d4 represents BPM number 5 in straight d4. bpm7dk and
% bpm7dr repreents BPM number 7 in either the kicker stright or RF
% straight.
bpm1d1 = [ d1a bpm d1b ];
bpm1d1k = inline(['['  num2str(d1ak1_up) ' '  'kicker '  num2str(d1ak2_up) ' '  num2str(bpm) ' '  num2str(d1b) ' '  ']' ], 'kicker'); % Kicker
bpm1d1r1 = [ d1ar1 bpm d1b ]; % RF 1 cavity
%bpm1d1r4 = [ d1ar4 bpm d1b ]; % RF 4 cavity
bpm2d4 = [ d4a bpm d4b ];
bpm3d4 = [ d4aa bpm d4bb ];
bpm4d2 = [ d2a bpm d2b ];
bpm5d4 = [ bpm2d4 ];
bpm6d4 = [ bpm3d4 ];
bpm7d1 = [ d1bb bpm d1aa ];
bpm7d1k = inline(['['  num2str(d1bb) ' '  num2str(bpm) ' '  num2str(d1ak2_do) ' '  'kicker '  num2str(d1ak1_do) ' '  ']' ], 'kicker'); % Kicker
bpm7d1r1 = [ d1b bpm d1ar1 ];  % RF 1 cavity
%bpm7d1r4 = [ d1b bpm d1ar4 ];  % RF 4 cavity
bpm1d1RF = [ dRF1 bpm dRF2 cav dRF2 cav dRF2 ];

d1ffb = [];
bpm7d1ffb = [ d1b bpm d1ffb ]; %fast feedback kicker

% Arrange the elements onto the girders and use markers to define the
% sections for misalignment studies.
g1m1 = marker('g1m1','IdentityPass');
g1m2 = marker('g1m2','IdentityPass');
g2m1 = marker('g2m1','IdentityPass');
g2m2 = marker('g2m2','IdentityPass');
% girder1 = [ g1m1 sfa hcor sfa d2 qfa d3 sda vcor sda g1m2];
% girder2 = [ g2m1 sdb vcor sdb d5 qda d6 qfb d2 sfb hcor sfb bpm4d2 qfb d6 qda d5 sdb vcor sdb g2m2];
% girder3 = [ g1m1 sda vcor sda d3 qfa d2 sfa hcor sfa g1m2];
girder1 = [ g1m1 sfa d2 qfa d3 sda g1m2];
girder2 = [ g2m1 sdb d5 qda d6 qfb d2 sfb bpm4d2 qfb d6 qda d5 sdb g2m2];
girder3 = [ g1m1 sda d3 qfa d2 sfa g1m2];

dipole_arc1 = [bpm2d4 dip1 bpm3d4];
dipole_arc2 = [bpm5d4 dip2 bpm6d4];

% Arrange the girders into the different cell arrangements.
unit_cel = [ bpm1d1 girder1 dipole_arc1 girder2 dipole_arc2 girder3 bpm7d1 ];
% Kickers in cells 1 and 14
celkick14 = [ bpm1d1k(kick1) girder1 dipole_arc1 girder2 dipole_arc2 girder3 bpm7d1k(kick2) ];
celkick01 = [ bpm1d1k(kick3) girder1 dipole_arc1 girder2 dipole_arc2 girder3 bpm7d1k(kick4) ];
% Shorten the straights in cells 6, 7 and 8 to put in the rf
% 4 RF cavities

celrf06_4 = [ bpm1d1RF girder1 dipole_arc1 girder2 dipole_arc2 girder3 bpm7d1 ];
celrf07_4 = [ bpm1d1RF girder1 dipole_arc1 girder2 dipole_arc2 girder3 bpm7d1 ];
%celrf06_4 = [ bpm1d1   girder1 dipole_arc1 girder2 dipole_arc2 girder3 bpm7d1r4 ];
%celrf07_4 = [ bpm1d1r4 girder1 dipole_arc1 girder2 dipole_arc2 girder3 bpm7d1r4 ];
%celrf08_4 = [ bpm1d1r4 girder1 dipole_arc1 girder2 dipole_arc2 girder3 bpm7d1   ];

% Single RF cavity
celrf06_1 = [ bpm1d1   girder1 dipole_arc1 girder2 dipole_arc2 girder3 bpm7d1r1 ];
celrf07_1 = [ bpm1d1r1 girder1 dipole_arc1 girder2 dipole_arc2 girder3 bpm7d1   ];
%diagnostic straight with fast feedback kicker
celffb10_1 = [ bpm1d1 girder1 dipole_arc1 girder2 dipole_arc2 girder3 bpm7d1ffb ]; %includes fast feedback kicker


% Definition of the types of rings
kickring    = [ ap celkick01 unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel celkick14];
cavity1ring = [ ap celkick01 unit_cel unit_cel unit_cel unit_cel celrf06_1 cav_single celrf07_1 unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel celkick14];;
cavity4ring = [ ap celkick01 unit_cel unit_cel unit_cel unit_cel celrf06_4 celrf07_4 unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel celkick14];

fullring_startwithRF = [ ap cav_single celrf07_1 unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel celkick14 celkick01 unit_cel unit_cel unit_cel unit_cel celrf06_1 ];
ring        = [ ap unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel unit_cel ];
%fast feedback kicker included:
ffbring     = [ ap celkick01 unit_cel unit_cel unit_cel unit_cel celrf06_1 cav_single celrf07_1 unit_cel unit_cel celffb10_1 unit_cel unit_cel unit_cel celkick14];
% wiggler ring (based on cavity4ring). Wiggler in sector 12
wigring = [ ap celkick01 unit_cel unit_cel unit_cel unit_cel celrf06_4 celrf07_4 unit_cel unit_cel unit_cel unit_cel wig unit_cel unit_cel app celkick14];

% Choose which lattice to load else load "fullring" as the default.
if nargin > 0
    fprintf('Using lattice : %s \n', varargin{1});
    eval(['buildlat(' varargin{1} ');']);
else
    % Default lattice to load
    fprintf('Using default lattice : wigring\n');
    buildlat(wigring);
end

% Make the variables THERING and GLOBVAL available to the caller's
% workspace.
evalin('caller','global THERING GLOBVAL');
disp('** Done **');

% New AT 1.3 does not require FAMLIST and is fazing out GLOBVAL
clear global FAMLIST

setenergymodel(3);

% Internal function used to return the length of a defined element.
function res = len(id)
global FAMLIST
res = FAMLIST{id}.ElemData.Length;

